# C++面经

- #### C和C++有什么区别
   - C： 面向过程编程

      Cpp： 面向对象编程，具有类、继承、多态、封装等特性

   - C： 不支持函数重载，每个函数名字唯一， 没有 **模版** 概念

      Cpp： 支持函数重载，参数列表不同即可， 有 **模版** 功能，允许用户创建泛型类和函数

   - C： 没有命名空间，所有标识符都是全局命名空间中

      Cpp： 支持命名空间，防止名字冲突

   - C： 使用 `malloc` 和 `free` 等基础函数进行内存管理

      Cpp：提供对象的构造和析构函数，用`delete` 和 `new` 管理内存

- #### 在C++中调用C函数，应该怎么做？为什么？如果要在C中调用C++又应该怎么做？

&nbsp; &nbsp; &nbsp; 如果在cpp中调用c函数，则需要使用‘ **extern "C"** ’进行**声明**， 防止C++编译器对C函数名进行改编，允许C++代码调用C库

```cpp
extern "C" { void c_function(); }
```
&nbsp; &nbsp; &nbsp; 如果在c中调用cpp，则需要创建一个C兼容的函数来作为包装器

```cpp
extern "C" void cpp_function() { // C++ code }
```

- #### C++中怎么new一个数组？怎么delete？如果delete没加[]会怎么样？

```cpp
int* myArray = new int[10]; 
delete[] myArray;
myArray = nullptr; 
//如果不将指针设置为nullptr，
//该指针仍然会指向之前的内存地址，
//但那块内存已经被释放，这样的指针称为悬垂指针
```

&nbsp; &nbsp; &nbsp; 如果没有是`delete`没有加`[]`， 会导致崩溃、数据损坏或内存泄漏，这是因为`delete`只是用来释放**单个对象**的内存，而`delete[]`被设计用来**释放数组分配的内存**并且会调用数组中每个对象的**析构函数。**

- #### C++中的多态是如何实现的？[详细可见面向对象.md](./面向对象.md)

&nbsp; &nbsp; &nbsp; C++中的多态主要通过函数重载、运算符重载、函数覆盖和虚函数来实现。函数重载和运算符重载属于编译时多态，根据参数的不同调用不同的函数。函数覆盖和虚函数则属于运行时多态，允许派生类中的函数覆盖基类中的同名函数，实现不同的功能

- #### 类中有虚函数，析构函数应该注意什么？

&nbsp; &nbsp; &nbsp;析构函数也应该设定为虚函数！

&nbsp; &nbsp; &nbsp;原因：

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1、当通过基类指针删除一个派生类对象时，如果基类的析构函数不是虚的，那么只有基类的析构函数会被调用，而派生类的析构函数不会被调用，则会导致派生类分配的资源没有被释放（多态的特性）
   
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2、如果是虚析构函数，则能确保当通过基类指针删除派生类对象时，对象的析构顺序是从派生类到基类，这样可以保证资源的正确释放。

- #### 什么情况下会触发虚函数？
   - 通过基类的指针或引用调用虚函数时，如果所指的对象是派生类的实例，那么将调用派生类中重写的版本，如果基类则调用虚函数本身
   - 基类的虚析构函数，在通过基类指针删除派生类对象时，会首先调用派生类的析构函数，再是基类的析构函数（触发虚函数）
   - 在继承过程中，如果派生类没有重写虚函数，那么将调用基类中的版本（虚函数）
   - 每个含有虚函数的类都有一个虚函数表（也称为vtable），它存储了虚函数地址的列表。当调用一个虚函数时，程序会查看对象的vtable来决定实际调用哪个函数。这是虚函数实现多态性的底层机制

   虚函数的触发不是由特定的代码行或语句直接决定的，而是由对象的实际类型和通过基类的接口（指针或引用）进行的调用这两个因素共同决定的。

- #### 虚函数和纯虚函数的区别？
   - 虚函数提供了具体的实现(有效的代码体)，允许派生类重写，纯虚则不提供具体的实现，要求子类必须提供这个函数的实现(除非子类也是抽象类)
   - 包含虚函数的类可以被实例化，包含纯虚函数的类是抽象类-不能实例化
     
- #### 指针和引用的区别？
   1. 指针的值是一个地址，可以通过重新赋值指向另一个不同地址。引用是一个别名，一旦引用被初始化指向一个变量，就不能改变为指向另一个变量
   2. 指针本身有内存地址和内存大小，引用只是一个别名通常不占用内存
   3. 指针可以为空，引用不能并且必须初始化
      
- #### char a=-1，在计算机内存中是怎么存储的？

   &nbsp; &nbsp; &nbsp; \-1是一个整数，赋给char时会发生类型转换，大多数计算机中整数类型用补码进行存储。内存中-1补码是‘11111111’--8位，这是有符号表示，如果无符号'11111111'表示255。

- #### 父类转子类安全吗？子类转父类安全吗？
   - 父类转子类不安全：父类不包含子类的额外成员。将父类类型的引用或指针赋值给子类类型的引用或指针时，如果实际上指向的不是子类对象，就会导致未定义的行为
   - 子类转父类安全：子类是父类的扩展，包含了父类的所有成员。将子类对象赋值给父类类型的引用或指针时，仅使用子类中的父类部分是类型安全的。

- #### 拷贝构造函数的参数要注意啥？
   - 参数通常是对常量对象的引用--const Type&， 这样做可以避免无限递归(不断调用拷贝构造函数复制参数）、保护源对象、提高效率（不进行非必要拷贝）
- #### 智能指针
   - `std::unique_ptr`: 同一时间内只能有一个`unique_ptr`拥有对某个对象的引用，离开作用域自动销毁。适合管理资源的生命周期，不支持复制。
   - `std::shared_ptr`: 允许多个`shared_ptr`实例共享对同一对象的所有权。它通过内部使用引用计数机制来实现，当最后一个`shared_ptr`被销毁或者重置时，它指向的对象才会被销毁。`shared_ptr`适合用于实现共享所有权的场景，如复杂的数据结构或共享资源
   - `std::weak_ptr`: 是一种配合`shared_ptr`使用的智能指针，不增加对象的引用计数。它用于解决`shared_ptr`相互引用导致的循环依赖问题，从而避免内存泄漏。`weak_ptr`可以从`shared_ptr`或另一个`weak_ptr`创建，并可以被提升为`shared_ptr`以访问对象
- #### 命名规则
   - **驼峰命名法（CamelCase）**：每个单词的首字母大写，不使用下划线分隔，如`MyExampleClass`。通常用于类名。
   - **小驼峰命名法（lowerCamelCase）**：第一个单词的首字母小写，后续单词的首字母大写，如`myExampleVariable`。常用于变量和函数名。
   - **下划线命名法（snake_case）**：所有字母小写，单词之间使用下划线分隔，如`my_example_function`。在某些编程语言和场景中，这种风格比较常见。
- #### 为什么做c++项目需要头文件
   - 头文件允许将声明（如函数、类和变量的声明）与定义（如函数和类成员函数的实际实现）分开，**提高代码的可读性和可维护性**
   - **方便重用和共享**，在多个源文件中包含同一个头文件，这样就可以在这些源文件中使用头文件中声明的函数和类
   - 能**提高编译效率**， 编译器只需要查看头文件而不是全部的实现代码
   - **提供了一种确保类型安全的机制**，一个源文件试图使用未声明的类型或函数，编译器将报错，从而减少运行时错误
   - 头文件提供了一种**封装**的方式，用户只需要关注接口-头文件中声明，降低了代码复杂度
- **讲出static的应用场景**
   - **函数内部声明的静态局部变量**具有静态存储期，这意味着它们在程序的执行期间**只被初始化一次**，且其值在函数调用之间保持不变，对于实现函数内部的状态保持或计数功能特别有用。
   - **类的静态成员变量**属于类本身，而不是类的某个特定对象，所有实例共享同一个静态成员变量，可以用于**类的实例计数**。
   - **类的静态成员函数**，还可以在**没有类实例化的情况**下调用，实现与类的实例(对象)无关的功能，比如返回类的实例数量
   - **静态全局变量与函数，**在全局或命名空间作用域中使用‘static’声明的变量或函数，其可见性将限制在声明它的文件中，这对于限制访问范围和避免命名冲突特别有用
- #### 我们在定义类成员函数时，函数末尾有一个const的作用是什么
   - 在C++中，在类成员函数的声明和定义末尾加上`const`关键字表示这个成员函数是“常量成员函数”。这意味着该函**数不会修改对象的任何数据成员**（不包括被声明为`mutable`的成员）
   - 例子：`getValue`函数被声明为`const`，这意味着它可以在常量对象`obj`上调用，并且保证不会修改`obj`的状态。如果尝试在`const`对象上调用非`const`成员函数（如`setValue`），则会导致编译错误。 也就是加了const能让常量对象直接调用
   - const可以用于重载成员函数，常量成员函数可以与非常量成员函数拥有相同的名称与参数列表，但是常量版本的函数可以在常量对象上调用，而非常量版本则可以修改对象的状态
- #### 如果我们想在c++项目中隐藏某些类的成员或函数，不暴露给外面，应该怎么做？
   - 可以使用`private`或`protected`访问修饰符。  C++类成员默认是`private`的，除非另有指定。通过将成员变量或成员函数声明为`private`，你可以阻止外部代码直接访问这些成员。`protected`成员在类外同样是不可访问的，但它们对派生类是可访问的
   - 可以使用匿名命名空间，或static关键字修饰全局函数和变量（都是仅在此文件中可见
- #### 拷贝构造函数中深拷贝与浅拷贝之间的区别
   - **浅拷贝仅复制对象的非静态成员变量的值**。如果成员变量是指针，**浅拷贝只复制指针的值**（即内存地址），而不复制指针所指向的数据（直接复制指针，即`data = other.data;`）
      - 由于两个对象的指针成员指向同一块内存地址，修改一个对象的指针成员所指向的数据可能会影响到另一个对象。此外，在对象销毁时，如果两个对象都尝试释放同一块内存，将导致双重释放问题（double free），这是一种常见的错误
      - 如果类不包含指向动态分配资源的指针，或者确保对象间共享相同的资源不会造成问题，可以使用浅拷贝
   - **深拷贝不仅复制对象的非静态成员变量的值**，如果成员变量包含指针，它还**会动态分配内存，并复制指针所指向的数据到新的内存区域**。这样，每个对象都拥有指向数据的独立副本（new 新的空间）
      - 深拷贝保证了对象间的完全独立，一个对象的修改不会影响到另一个对象。每个对象负责自己内部资源的管理，这避免了双重释放等问题
      - 通常当类中包含指向动态分配资源的指针时，需要实现深拷贝来确保资源的正确复制和管理

