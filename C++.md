# C++面经

- #### C和C++有什么区别
   - C： 面向过程编程

      Cpp： 面向对象编程，具有类、继承、多态、封装等特性

   - C： 不支持函数重载，每个函数名字唯一， 没有 **模版** 概念

      Cpp： 支持函数重载，参数列表不同即可， 有 **模版** 功能，允许用户创建泛型类和函数

   - C： 没有命名空间，所有标识符都是全局命名空间中

      Cpp： 支持命名空间，防止名字冲突

   - C： 使用 `malloc` 和 `free` 等基础函数进行内存管理

      Cpp：提供对象的构造和析构函数，用`delete` 和 `new` 管理内存

- #### 在C++中调用C函数，应该怎么做？为什么？如果要在C中调用C++又应该怎么做？

&nbsp; &nbsp; &nbsp; 如果在cpp中调用c函数，则需要使用‘ **extern "C"** ’进行**声明**， 防止C++编译器对C函数名进行改编，允许C++代码调用C库

```cpp
extern "C" { void c_function(); }
```
&nbsp; &nbsp; &nbsp; 如果在c中调用cpp，则需要创建一个C兼容的函数来作为包装器

```cpp
extern "C" void cpp_function() { // C++ code }
```

- #### C++中怎么new一个数组？怎么delete？如果delete没加[]会怎么样？

```cpp
int* myArray = new int[10]; 
delete[] myArray;
myArray = nullptr; 
//如果不将指针设置为nullptr，
//该指针仍然会指向之前的内存地址，
//但那块内存已经被释放，这样的指针称为悬垂指针
```

&nbsp; &nbsp; &nbsp; 如果没有是`delete`没有加`[]`， 会导致崩溃、数据损坏或内存泄漏，这是因为`delete`只是用来释放**单个对象**的内存，而`delete[]`被设计用来**释放数组分配的内存**并且会调用数组中每个对象的**析构函数。**

- #### C++中的多态是如何实现的？[详细可见面向对象.md](./面向对象.md)

&nbsp; &nbsp; &nbsp; C++中的多态主要通过函数重载、运算符重载、函数覆盖和虚函数来实现。函数重载和运算符重载属于编译时多态，根据参数的不同调用不同的函数。函数覆盖和虚函数则属于运行时多态，允许派生类中的函数覆盖基类中的同名函数，实现不同的功能

- #### 类中有虚函数，析构函数应该注意什么？

&nbsp; &nbsp; &nbsp;析构函数也应该设定为虚函数！

&nbsp; &nbsp; &nbsp;原因：

&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1、当通过基类指针删除一个派生类对象时，如果基类的析构函数不是虚的，那么只有基类的析构函数会被调用，而派生类的析构函数不会被调用，则会导致派生类分配的资源没有被释放（多态的特性）
   
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2、如果是虚析构函数，则能确保当通过基类指针删除派生类对象时，对象的析构顺序是从派生类到基类，这样可以保证资源的正确释放。

- #### 什么情况下会触发虚函数？
   - 通过基类的指针或引用调用虚函数时，如果所指的对象是派生类的实例，那么将调用派生类中重写的版本，如果基类则调用虚函数本身
   - 基类的虚析构函数，在通过基类指针删除派生类对象时，会首先调用派生类的析构函数，再是基类的析构函数（触发虚函数）
   - 在继承过程中，如果派生类没有重写虚函数，那么将调用基类中的版本（虚函数）
   - 每个含有虚函数的类都有一个虚函数表（也称为vtable），它存储了虚函数地址的列表。当调用一个虚函数时，程序会查看对象的vtable来决定实际调用哪个函数。这是虚函数实现多态性的底层机制

   虚函数的触发不是由特定的代码行或语句直接决定的，而是由对象的实际类型和通过基类的接口（指针或引用）进行的调用这两个因素共同决定的。

- #### 虚函数和纯虚函数的区别？
   - 虚函数提供了具体的实现(有效的代码体)，允许派生类重写，纯虚则不提供具体的实现，要求子类必须提供这个函数的实现(除非子类也是抽象类)
   - 包含虚函数的类可以被实例化，包含纯虚函数的类是抽象类-不能实例化
     
- #### 指针和引用的区别？
   1. 指针的值是一个地址，可以通过重新赋值指向另一个不同地址。引用是一个别名，一旦引用被初始化指向一个变量，就不能改变为指向另一个变量
   2. 指针本身有内存地址和内存大小，引用只是一个别名通常不占用内存
   3. 指针可以为空，引用不能并且必须初始化
      
- #### char a=-1，在计算机内存中是怎么存储的？

   \-1是一个整数，赋给char时会发生类型转换，大多数计算机中整数类型用补码进行存储。内存中-1补码是‘11111111’--8位，这是有符号表示，如果无符号'11111111'表示255。

- #### 父类转子类安全吗？子类转父类安全吗？
   - 父类转子类不安全：父类不包含子类的额外成员。将父类类型的引用或指针赋值给子类类型的引用或指针时，如果实际上指向的不是子类对象，就会导致未定义的行为
   - 子类转父类安全：子类是父类的扩展，包含了父类的所有成员。将子类对象赋值给父类类型的引用或指针时，仅使用子类中的父类部分是类型安全的。

